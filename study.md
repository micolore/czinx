# zinx  框架

### 服务器

#### 服务器启动都做了哪些事情？
     从最开始的基本服务器设计模型到0.10版本，之间的变动还是很大的，基本上都是在不停的优化，重构组件
     c1 ----》s  
        客户端链接到服务器，服务器之间都经历了哪些过程？ 
        1 服务器创建、并监听端口号
        2 服务器处理请求上
           2.1 v0.1 
               2.1.1 初始化服务器的相关信息(ip、端口号、服务名称、版本号) 
               2.1.2 给服务器增加基本的操作（启动、停止、关闭）
               2.1.3 服务器只提供单线程的读、写客户端链接的操作
           2.2 v0.3
               v0.1的问题是什么呢？
                 所有的链接都是同一个业务，功能服务太单一了，局限性很大，那么怎么才能实现不同的服务呢
               2.3.1 封装请求的相关信息到request里面
                     request应该有哪些属性呢？
                     首先第一个问题就是，一个请求，其实就是一个连接，那么连接相关信息应该是可以（需要）放到       request里面的，其次是请求的内容，也应该放到request里面。
                     有了request对象，那么还需要做哪些事情才能实现路由？
                     路由应该处理什么？怎么进行处理？
               2.3.2 新增路由相关接口，定义路由相关的方法（是否像拦截器）
                     方法如下：处理conn业务之前、处理conn业务之后、处理conn业务
                     路由新增好了，那应该把它放到哪里（组件内）合适？
               2.3.3 给服务器增加一个添加路由的方法（是否像绑定操作）
                     
                     * 为什么还要给conn绑定一个router？
               2.3.4 服务监听的时候，创建连接的时候传入一个router对象      
                     *但是好像没有初始化操作，因为创建conn对象的时候，给了一个nil值
                      test server after start add one router，后面可能有多个router，so init conn的时候是直接 get an router form server
             2.3 v0.4 增加参数（全局）配置         
                2.4.1 新增全局配置
                2.4.2 新增配置文件 
             2.4 消息封装
                 消息封装的主要目标是什么？以及消息封装的主要目的？
                 粘包只是原因之一，但不是主要原因
                 消息的基本属性都有哪些？长度、内容、消息id
                 2.4.1 创建消息对象
                 2.4.2 定义消息封包、拆包的相关操作
                      拆包:从客户端传递的字节数组--》消息（解压数据）
                        需要注意获取的长度与服务器全局的配置是否满足其大小限制
                      封包:从消息====》字节数组（ 压缩数据）
                      *关于包头的长度问题是如何定义的，还不是很明白
               2.5 多路由模式  
            	 2.5.1 原来的路由是由服务器进行维护的，只有一个属性 router
				       现在如果让它支持多个router的话，应该怎么进行设计？（其实就是把属性的值类型由单个结构体换成map结构<key-router>）
					这样就可以简单的实现多router模式
					   但是问题来了应该把这个apis放在哪里？
					   服务器接口新增一个添加router的方法，并且由实现者server新增 一个msghandler	 
            
               2.6 读写分离
               2.7 消息队列
               2.8 链接管理
               2.9 连接属性
                      


​                 
​           
​         
     c1《---- s
        1 服务器处理请求下
        2 服务返回信息到客户端


#### 


####  链接

##### 链接的基本属性都由哪些？

##### 链接如何打开？什么时候打开？由谁来打开？

##### 链接如何关闭？什么时候关闭？由谁来关闭？

##### 如何处理链接

##### 链接如何读取客户端数据

##### 链接如何往客户端写数据


####  配置

## history 

### v0.1
   基本的server(client)
### v0.2
   简单封装链接
### v0.3
   增加路由功能
### v0.4
   服务器基本信息配置化
### v0.5 
   消息再封装
    *还有很多语法的问题，以及教程的部分代码跑不通，需要稍微修改一下才行   
    
### v0.6
    多路由

### v0.7
    读写分离

### v0.8 
    消息队列+多任务
### v0.9 
    链接管理


​                
## 问题记录

### 2019-12-5 星期四
    * 基本代码写完了，但是很多细节以及设计原理还没有深入的思考，后面花一点时间来进行思考（加注释，用自己的话来重复的解释一遍），不仅是go语法上的，还有服务器架构上的。
    * https://github.com/alfred-zhong/wserver 这个太基础了，处理的链接数量有限，即使负载了也不一定有用
    * request、connection、msg之间的关系，以及它们与server的关系
    * router 、server、msghandle的关系
      一个服务只能有一个server，一个server只能有一个msghandle，一个msghandle有多个router，在当前这个版本里面是由一个msghandle来进行管理所有的router实例 